---
title: 'Dynamic Schemas'
description: 'How Rastro automatically manages your catalog schemas'
---

## Overview

Unlike traditional databases that require predefined schemas, Rastro uses **dynamic schemas** that evolve automatically as your data changes.

## How It Works

<Steps>
  <Step title="Add Data">
    You add items with any fields you need
  </Step>
  <Step title="Schema Inference">
    Rastro analyzes the data and infers field types
  </Step>
  <Step title="Schema Evolution">
    New fields are automatically added to the schema
  </Step>
  <Step title="Version Increment">
    Schema version increments (e.g., 1.0 â†’ 1.1)
  </Step>
</Steps>

## Example

```python
# Day 1: Initial product
{
    "sku": "LAPTOP-001",
    "title": "Laptop",
    "price": 999.99
}
# Schema v1.0: sku (string), title (string), price (number)

# Day 2: Add more detail
{
    "sku": "LAPTOP-002",
    "title": "Pro Laptop",
    "price": 1499.99,
    "brand": "TechCorp",      # NEW
    "specifications": {        # NEW
        "cpu": "Intel i7",
        "ram": "16GB"
    }
}
# Schema v1.1: + brand (string), specifications (object)

# Day 3: Add inventory tracking
{
    "sku": "LAPTOP-003",
    "title": "Gaming Laptop",
    "price": 1999.99,
    "brand": "GamePro",
    "in_stock": true,          # NEW
    "quantity": 25             # NEW
}
# Schema v1.2: + in_stock (boolean), quantity (integer)
```

## Schema Version

Each schema change increments the version:

| Change | Version |
|--------|---------|
| Initial schema | 1.0 |
| Add 1 field | 1.1 |
| Add 2 fields | 1.2 |
| Major restructure | 2.0 |

<Info>
  Schema versions are tracked for auditing. You can always see when fields were added.
</Info>

## Type Inference

Rastro infers types from the first non-null value:

| Data | Inferred Type |
|------|---------------|
| `"hello"` | string |
| `123` | integer |
| `99.99` | number |
| `true` | boolean |
| `["a", "b"]` | array |
| `{"key": "val"}` | object |

### Mixed Types

If a field has different types across items, Rastro uses the most permissive type:

```python
# Item 1: price as string
{"sku": "A", "price": "29.99"}

# Item 2: price as number
{"sku": "B", "price": 39.99}

# Schema: price (string) - string is more permissive
```

<Warning>
  For best results, use consistent types for the same field across all items.
</Warning>

## Schema Fields

View your catalog's schema:

```bash
GET /public/catalogs/{catalog_id}/schema
```

Response:

```json
{
  "version": "1.2",
  "fields": [
    {
      "name": "sku",
      "type": "string",
      "required": true,
      "description": "Unique product identifier"
    },
    {
      "name": "title",
      "type": "string",
      "required": false
    },
    {
      "name": "price",
      "type": "number",
      "required": false
    },
    {
      "name": "brand",
      "type": "string",
      "required": false
    },
    {
      "name": "specifications",
      "type": "object",
      "required": false
    }
  ],
  "updated_at": "2024-01-15T10:30:00Z"
}
```

## Schema Rules

### What Happens Automatically

<CardGroup cols={2}>
  <Card title="New Fields" icon="plus">
    Added automatically when encountered
  </Card>
  <Card title="Type Detection" icon="magnifying-glass">
    Inferred from data values
  </Card>
</CardGroup>

### What Doesn't Happen

<CardGroup cols={2}>
  <Card title="Field Removal" icon="trash">
    Fields are never auto-removed
  </Card>
  <Card title="Type Changes" icon="rotate">
    Types don't change automatically
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Plan Your Core Fields">
    While schemas are flexible, plan your essential fields upfront (sku, title, price, etc.)
  </Accordion>

  <Accordion title="Use Consistent Naming">
    Use `snake_case` or `camelCase` consistently. Don't mix `productTitle` and `product_title`.
  </Accordion>

  <Accordion title="Validate Before Import">
    Clean your data before bulk imports to avoid schema pollution from bad data.
  </Accordion>

  <Accordion title="Document Custom Fields">
    Keep track of custom fields you add and their intended purposes.
  </Accordion>
</AccordionGroup>

## Workflow Schema Evolution

When running AI workflows, schemas can evolve based on enrichment:

```python
# Input
{"sku": "ABC", "title": "Laptop"}

# After AI enrichment workflow
{
    "sku": "ABC",
    "title": "Laptop",
    "ai_description": "High-performance laptop...",  # NEW
    "ai_category": "Electronics > Computers",         # NEW
    "ai_keywords": ["laptop", "computer", "tech"]     # NEW
}
# Schema evolves to include AI-generated fields
```

<Tip>
  Workflows automatically add their output fields to your schema. No manual configuration needed.
</Tip>
